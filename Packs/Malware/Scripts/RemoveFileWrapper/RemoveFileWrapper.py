"""

"""

import demistomock as demisto
from CommonServerPython import *

import traceback

''' STANDALONE FUNCTION '''


def create_commands_wrapper(device_ids: List[str], file_path: str) -> List[CommandWrapper]:
    """
    Create a list of `CommandWrapper` of the remove file command to `Cortex XDR` and `CrowdstrikeFalcon`

    :param device_ids: The device id's to run on
    :param file_path: The file_path to delete
    :return: A list of `CommandWrapper` for the script
    """
    cs_os_to_ids = get_crowdstrike_os_to_id(device_ids)
    return [CommandWrapper(brand='Cortex XDR - IR',
                           commands='xdr-run-script-delete-file',
                           args_lst={'endpoint_ids': ','.join(device_ids),
                                     'file_path': file_path}),
            CommandWrapper(brand='CrowdstrikeFalcon',
                           commands=['cs-falcon-rtr-remove-file' for _ in cs_os_to_ids],
                           args_lst=[{'host_ids': ','.join(ids),
                                      'file_path': file_path,
                                      'os': os_}
                                     for os_, ids in cs_os_to_ids.items()])]


def get_crowdstrike_os_to_id(device_ids: List[str]) -> Dict[str, Set[str]]:
    """
    Get the OS for each device id

    :param device_ids: List of device ids
    :return: A mapping between the OS (Windows, Linux, Mac) and the devices
    """
    endpoint_results, endpoint_errors = execute_commands_multiple_results('endpoint',
                                                                          {'id': ','.join(device_ids),
                                                                           'using-brand': 'CrowdstrikeFalcon'},
                                                                          extract_contents=True)
    os_to_ids: Dict[str, Set[str]] = {}
    for endpoint_res in endpoint_results:
        if not isinstance(endpoint_res.result, dict):
            continue
        for endpoints in endpoint_res.result.get('resources', []):
            if not isinstance(endpoints, list):
                endpoints = [endpoints]
            for endpoint in endpoints:
                os_ = endpoint.get('platform_name')
                if os_ not in os_to_ids:
                    os_to_ids[os_] = set()
                os_to_ids[os_].add(endpoint.get('device_id'))
    return os_to_ids


def run_remove_file(device_ids: List[str], file_path: str) -> list:
    """
    Given arguments to the command, returns a list of results to return

    :param device_ids: List of device ids to remove the file from
    :param file_path: The filepath to remove

    :return: list of results to return
    :rtype: ``list``
    """

    command_wrappers = create_commands_wrapper(device_ids, file_path)
    return get_wrapper_results(command_wrappers)


''' MAIN FUNCTION '''


def main():  # pragma: no cover
    args = demisto.args()
    device_ids = argToList(args.get('device_ids'))
    file_path = args.get('file_path')
    if not device_ids:
        raise ValueError('Device id is not specified')
    if not file_path:
        raise ValueError('File path is not specified')
    try:
        return_results(run_remove_file(device_ids, file_path))
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute RemoveFileWrapper. Error: {str(ex)}')


''' ENTRY POINT '''

if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
