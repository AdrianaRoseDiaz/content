"""Base Script for Cortex XSOAR (aka Demisto)

This is an empty script with some basic structure according
to the code conventions.

MAKE SURE YOU REVIEW/REPLACE ALL THE COMMENTS MARKED AS "TODO"

Developer Documentation: https://xsoar.pan.dev/docs/welcome
Code Conventions: https://xsoar.pan.dev/docs/integrations/code-conventions
Linting: https://xsoar.pan.dev/docs/integrations/linting

"""

import demistomock as demisto
from CommonServerPython import *
from CommonServerUserPython import *

import traceback

''' STANDALONE FUNCTION '''

BRANDS = ['Cortex XDR - IR',
          'Microsoft Defender Advanced Threat Protection',
          'CrowdstrikeFalcon']

INCIDENT_ID = demisto.incident().get('id')

XDR_ACTIONS = {
    'allow': 'xdr-whitelist-files',
    'block': 'xdr-blacklist-files'
}

MSDE_ACTIONS = {
    'allow': 'Allowed',
    'block': 'AlertAndBlock',
}

CROWDSTRIKE_ACTIONS = {
    'allow': {'action': 'allow',
              'description': f'Whitelisted based on XSOAR inc {INCIDENT_ID}',
              'severity': 'low'},
    'block': {'action': 'prevent',
              'description': f'Blacklisted based on XSOAR inc {INCIDENT_ID}',
              'severity': 'high'}
}


def create_commands_wrapper(hashes: List[str], action: str):
    return [CommandWrapper(brand='Cortex XDR - IR',
                           command=XDR_ACTIONS.get(action),
                           args={'hash_list': ','.join(hashes)}),
            CommandWrapper(brand='Microsoft Defender Advanced Threat Protection',
                           command='microsoft-atp-sc-indicator-create',
                           args=[{'indicator_value': h,
                                  'indicator_type': 'FileSha256',
                                  'action': MSDE_ACTIONS.get(action),
                                  'indicator_description': f'XSOAR - related incident {INCIDENT_ID}',
                                  'indicator_titlâ‰ˆe': f'XSOAR - related incident {INCIDENT_ID}'} for h in hashes]),
            CommandWrapper(brand='CrowdstrikeFalcon',
                           func=run_crowdstrike_falcon_action)]


def run_crowdstrike_falcon_action(hashes: List[str], action):
    falcon_results, falcon_errors = [], []
    ioc_metadata = CROWDSTRIKE_ACTIONS.get(action)
    search_results, errors_search = execute_commands_multiple_results('cs-falcon-search-custom-iocs',
                                                                      {'values': ','.join(hashes)},
                                                                      extract_contents=True
                                                                      )
    falcon_errors.extend(errors_search)

    for search_res in search_results:
        search_results_hashes = [ioc.get('value') for ioc in search_res.result.get('resources', [])]
        new_hashes = [h for h in hashes if h not in search_results_hashes]
        for h in new_hashes:
            results, errors = execute_commands_multiple_results('cs-falcon-upload-custom-ioc',
                                                                {'ioc_type': 'sha256',
                                                                 'platforms': 'linux,mac,windows',
                                                                 'applied_globally': 'true',
                                                                 'value': h,
                                                                 **ioc_metadata}, extract_contents=False)
            falcon_errors.extend(errors)
            falcon_results.extend(results)
        for ioc in search_res.result.get('resources', []):
            results, errors = execute_commands_multiple_results('cs-falcon-update-custom-ioc',
                                                                {'ioc_id': ioc.get('id'),
                                                                 **ioc_metadata}, extract_contents=False)
            falcon_errors.extend(errors)
            falcon_results.extend(results)

    return falcon_results, falcon_errors


def run_hash_action(hashes: List[str], action: str) -> list:
    """Returns a simple python dict with the information provided
    in the input (dummy).

    :type hashes: ``List[str]``
    :param hashes: string to add in the dummy dict that is returned

    :return: dict as {"dummy": dummy}
    :rtype: ``str``
    """
    command_wrappers = create_commands_wrapper(hashes, action)
    return create_generic_wrapper(BRANDS, command_wrappers, hashes, action)


''' MAIN FUNCTION '''


def main():
    hashes = argToList(demisto.args().get('hash', None))
    action = demisto.args().get('action')
    if not hashes:
        raise ValueError('hash not specified')
    if not action or action not in {'allow', 'block'}:
        raise ValueError('Action not specified or not in allowed actions')
    try:
        return_results(run_hash_action(hashes, action))
    except Exception as ex:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute HashWrapper. Error: {str(ex)}')


''' ENTRY POINT '''

if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
